1. Vehicle Direction Task
This task is purely periodic - in my implementation, I use a period of ~100ms.  In "vehicleDirectoinTask_periodic.png", you can
see this period.  Let's zoom in further.  If you look at "vehicleDirectionTask_nochange", you can see an instance where the 
direction had not changed, so after the Vehicle Direction Task, it goes directly into the idle task.  If you look at 
"vehicleDirectionTask_changedvalue", you can see an instance where the direction value was found to have changed, so the Vehicle
Monitor Task is run immediately after. If you look at "vehicleDirectionTask_alert.png", we can see an instance where the 
direction alert was generated by holding a direction too long.  The Vehicle Monitor Task passes a flag to the LED Output Task, 
which we can see runs immediately following the Vehicle Monitor Task.

2. Speed Setpoint Task
This task is only entered when a pushbutton is pushed and hte GPIO ISR is ran.  Looking at "speedSetpointTask.png", we can see
that the Speed Setpoint Task is directly preceded by "ISR 26" (the GPIO ISR), and followed by the Vehicle Monitor Task, because
any changes to speed or direction causes that task to be ran.  If we look at "speedSetpointTask_alert.png", we can see an instance 
where I drove my little car over 75mph, so the flow of events is the same as described in the previous sentence, but because the 
Vehicle Monitor Task noticed a violation, the LED Output Task follows.

3. Vehicle Monitor Task
This task runs when there are changes to the speed or direction.  I have demonstrated this functionality in 1. and 2., for both
speed and direction changes.  

4. LED Output Task
This task runs when a violation flag is received from the Vehicle Monitor Task.  I have demonstrated this functionality in 1. and 2., 
for both speed and direction violations.

5. LCD Output Task
This task is purely periodic.  If you look at "LCDDisplayTask.png", you can see my period of ~100ms between instances of this task.
Another interesting note here: the way I coded this task is to exit quickly if there are no changes made to direction or speed, and 
therefore no changes need to be reflected on the display.  This is good because the vast majority of the time this task is ran there will
not be any changes to the data to display.  In the same screenshot notice that the LCD Display Task that occurs first
(on the left) is very quick, less than 1ms - this is an instance where no changes were made.  On the right, the next instance is 115.2ms, 
which is a long time!  "printf"s naturally take a long time, because they are sending binary data strings with a baud that is relatively
slow compared to tasks occuring solely within the CPU.

All the tasks are running as expected!